---
layout: notes
title: "Векторные расширения над SQL базами данных"
lecture: "vector-databases-ann"
order: 2
description: "Глубокий и системный разбор векторных расширений над БД, их сравнение с классическими векторными БД"
estimated_reading: "30 мин"
---

### **Раздел 0: Введение и терминологический аппарат**

#### **0.1. Предмет и структура документа**

Этот материал представляет собой архитектурный анализ подходов к интеграции векторного поиска для RAG-систем. Вместо обзора отдельных продуктов,здесь классифицируются и сопоставляются три фундаментальные парадигмы: использование специализированных векторных движков, расширение функциональности классических баз данных и применение платформ класса "Бэкенд как Сервис".

Центральное место в анализе занимают три ключевые технологии, представляющие разные подходы:
1.  **`pgvector`** — как пример расширения для реляционной СУБД PostgreSQL.
2.  **`MongoDB Atlas Vector Search`** — как пример интеграции в документо-ориентированную NoSQL-платформу.
3.  **`Supabase`** — как пример BaaS-платформы, предоставляющей векторный поиск в виде управляемого сервиса на базе `pgvector`.

Цель документа — предоставить инженерам и архитекторам систему координат для принятия обоснованных решений через анализ внутренней механики, преимуществ и компромиссов каждого из этих подходов.

#### **0.2. Глоссарий**

Термины, используемые в тексте.

*   **Backend-as-a-Service (BaaS)**
    *   Модель предоставления облачных услуг, включающая управляемый бэкенд-стек: базу данных, API-шлюз, сервис аутентификации и хранилище. Позволяет разработчикам абстрагироваться от управления серверной инфраструктурой. *Примеры: Supabase, Firebase.*
- **DBA (Data Base Administator)**
	- Администратор Баз Данных
*   **Developer Experience (DX)**
    *   Совокупная оценка удобства и эффективности работы с программным инструментом или платформой. Определяется качеством документации, дизайном API и SDK, а также интуитивностью пользовательских интерфейсов.
- **B-tree**
	-  Структура данных в виде сбалансированного дерева, которая обеспечивает быстрый поиск, вставку и удаление данных по значениям столбцов. В **PostgreSQL** B-tree индекс используется по умолчанию и особенно эффективен для поиска по точному значению и диапазону.
- 
*   **Pre-filtering vs. Post-filtering**
    *   Два различных метода применения фильтрации по метаданным при векторном поиске:
        *   **Pre-filtering:** Фильтрация выполняется *до* или *во время* ANN-поиска, что позволяет сократить исходное пространство поиска. Метод демонстрирует высокую эффективность при работе с высокоселективными фильтрами.
        *   **Post-filtering:** ANN-поиск выполняется первым для нахождения `k` кандидатов, к которым *впоследствии* применяется фильтрация. Данный метод менее эффективен и может приводить к возврату неполного набора результатов.

*   **Квантование (Quantization)**
    *   Техника снижения битовой точности числовых представлений векторов с целью сокращения занимаемой памяти и ускорения вычислений. Распространенной практикой является преобразование векторов из формата `float32` в `int8`, что обеспечивает до 4-кратной экономии ресурсов при минимальной потере точности.

- **ACID** — это четыре ключевых свойства транзакций в базах данных:
	* **Атомарность** — все операции внутри транзакции выполняются полностью или не выполняются вовсе,
	* **Согласованность** — данные всегда остаются корректными,
	* **Изолированность** — параллельные транзакции не мешают друг другу,
	* **Устойчивость** — зафиксированные изменения не пропадут даже при сбое системы.

*   **Селективность фильтра**
    *   Характеристика условия фильтрации, определяющая долю отсеиваемых им данных из общего набора. **Высокоселективный** фильтр оставляет незначительное подмножество данных. **Низкоселективный** фильтр оставляет значительную их часть.

*   **Привязка к поставщику (Vendor Lock-in)**
    *   Зависимость от проприетарных технологий или API, которая существенно затрудняет или делает экономически нецелесообразной миграцию на альтернативную платформу. Является фактором стратегического риска при выборе технологии.

### **Раздел 1: Классификация архитектурных подходов**

Интегрировать векторный поиск в приложение можно с помощью нескольких принципиально разных архитектурных подходов. Выбранный подход напрямую влияет на ключевые системные характеристики: сложность архитектуры, операционные издержки, производительность и целостность данных. Ниже представлена классификация этих подходов.

#### **1.1. Специализированные векторные базы данных**

Это автономные базы данных, созданные специально для одной задачи: эффективного хранения, индексации и поиска векторов.

*   **Ключевые характеристики:**
    *   **Оптимизация производительности:** Архитектура полностью сфокусирована на выполнении ANN-поиска с минимальными задержками.
    *   **Современные возможности:** Обычно "из коробки" поддерживают квантование (SQ, PQ), гибридный поиск и другие передовые алгоритмы.
    *   **Архитектурные издержки:** Внедрение такой базы добавляет в стек новый компонент. Это требует настройки синхронизации данных с основной базой и усложняет общую архитектуру.

*   **Представители:** Qdrant, Milvus, Weaviate, Pinecone.

#### **1.2. Векторный поиск как расширение для классических баз данных**

В этом подходе векторный поиск не выделяется в отдельный сервис, а добавляется как новая функция в уже используемую, многоцелевую базу данных.

*   **Ключевые характеристики:**
    *   **Единый источник данных:** Не нужно поддерживать отдельное хранилище векторов и настраивать сложную синхронизацию. Основная база остается единым источником истины.
    *   **Целостность данных:** Позволяет использовать нативные механизмы, например, ACID-транзакции в реляционных базах, для атомарной записи бизнес-данных и их векторов.
    *   **Конкуренция за ресурсы:** Векторные операции используют те же системные ресурсы (CPU, RAM, I/O), что и остальные запросы, что может повлиять на общую производительность.

*   **Подкатегории:**
    *   **1.2.1. Реляционные СУБД:** Интеграция в базы данных со строгой схемой. Позволяет задействовать всю мощь SQL для фильтрации. *Пример: `pgvector` для PostgreSQL.*
    *   **1.2.2. Документо-ориентированные СУБД:** Интеграция в базы с гибкой схемой. Поиск становится частью мощных конвейеров обработки документов. *Пример: `Atlas Vector Search` для MongoDB.*

#### **1.3. Векторный поиск как часть платформ BaaS (Backend-as-a-Service)**

Здесь векторный поиск — это одна из встроенных функций комплексной облачной платформы, которая предоставляет весь бэкенд как управляемый сервис.

*   **Ключевые характеристики:**
    *   **Полностью управляемый сервис:** Платформа берет на себя все операционные задачи: развертывание, масштабирование, обслуживание и обеспечение безопасности.
    *   **Фокус на скорости разработки:** Предоставляются готовые SDK, API и UI для всех компонентов, что значительно ускоряет вывод продукта на рынок.
    *   **Ограниченный низкоуровневый контроль:** В обмен на удобство разработчик получает меньше возможностей для тонкой настройки производительности и конфигурации базовых компонентов.

*   **Представители:** Supabase, Firebase.

### **Раздел 2: Анализ векторных расширений для универсальных СУБД**

Данный раздел посвящен детальному анализу подхода, при котором функциональность векторного поиска интегрируется в существующие многоцелевые базы данных. Рассматриваются две ключевые реализации: `pgvector` для реляционной СУБД PostgreSQL и `Atlas Vector Search` для документо-ориентированной платформы MongoDB Atlas.

#### **2.1. `pgvector`: Интеграция в реляционную модель PostgreSQL**

##### **2.1.1. Архитектурная реализация и философия**

`pgvector` представляет собой расширение (extension) для PostgreSQL, которое вводит в систему новый тип данных `vector` и соответствующие методы индексации (ANN). Ключевая особенность этого подхода заключается в том, что векторы становятся нативной частью реляционной модели. Они не являются внешними сущностями, а наследуют все системные характеристики PostgreSQL, включая транзакционность, механизмы фильтрации и экосистему инструментов.

##### **2.1.2. Преимущества**

*   **Транзакционность (ACID):** Запись бизнес-данных и их векторных представлений может выполняться в рамках одной атомарной транзакции, что гарантирует целостность и исключает риски рассинхронизации.
*   **Мощность SQL-фильтрации:** Предоставляется возможность использовать всю полноту SQL для фильтрации данных. Это включает сложные условия в `WHERE`, объединение таблиц через `JOIN`, а также работу со специфическими типами данных, такими как `JSONB` или геоданные (при использовании `PostGIS`). Планировщик запросов Postgres автоматически выбирает оптимальную стратегию выполнения.
*   **Единая экосистема:** Интеграция с существующими инструментами PostgreSQL происходит бесшовно. Стандартные утилиты (`pg_dump`), библиотеки (`psycopg2`, `SQLAlchemy`), ORM и системы мониторинга продолжают функционировать без изменений. Нативные механизмы безопасности, такие как Row-Level Security (RLS), также применимы к таблицам с векторами.

##### **2.1.3. Недостатки и компромиссы**

*   **Конкуренция за системные ресурсы:** Векторные операции конкурируют за общие ресурсы сервера (CPU, I/O, RAM) с остальными запросами. В частности, ANN-индексы требуют значительного объема RAM (в кэше `shared_buffers`), и их производительность может деградировать под влиянием других тяжелых запросов.
*   **Отсутствие нативного квантования:** На данный момент `pgvector` не поддерживает техники сжатия векторов, такие как скалярное или продуктовое квантование. Это приводит к линейному росту требований к оперативной памяти при увеличении объема данных и напрямую влияет на стоимость инфраструктуры.
*   **Операционная сложность при масштабировании:** Начальное развертывание просто, однако эффективная эксплуатация под высокой нагрузкой требует глубокой экспертизы в администрировании PostgreSQL. Задачи по тюнингу производительности, настройке репликации и шардированию требуют квалификации уровня DBA (Администратор Баз Данных).

##### **2.1.4. Механизмы индексации и поиска**

*   **Поддерживаемые алгоритмы:**
    *   **`IVFFlat` (Inverted File with Flat Compression):** Эффективен для статических наборов данных среднего размера (до ~10 млн векторов). Требует перестроения индекса при добавлении новых данных.
    *   **`HNSW` (Hierarchical Navigable Small World):** Обеспечивает более высокую скорость поиска и подходит для больших, динамически изменяемых наборов данных.

*   **Механизм фильтрации при использовании HNSW:** Алгоритм HNSW по своей природе не поддерживает pre-filtering. `pgvector` обходит это ограничение с помощью планировщика запросов PostgreSQL, который выбирает один из двух планов выполнения:
    1.  **Filtered Search (для низкоселективных фильтров):** Выполняется стандартный обход HNSW-графа. На каждом шаге узел-кандидат проверяется на соответствие условиям `WHERE`.
    2.  **Pre-filtering + Brute-force (для высокоселективных фильтров):** При наличии B-Tree индекса на фильтруемом столбце планировщик может полностью изменить стратегию. Сначала он использует B-Tree индекс для получения малого набора кандидатов, а затем выполняет точный (brute-force) поиск по этому подмножеству, полностью игнорируя ANN-индекс на начальном этапе. Это обеспечивает высокую производительность при точечных запросах.

#### **2.2. `Atlas Vector Search`: Интеграция в документо-ориентированную модель MongoDB**

##### **2.2.1. Архитектурная реализация и философия**

`Atlas Vector Search` является встроенной функцией облачной платформы MongoDB Atlas, недоступной в self-hosted версиях. Его архитектура основана на интеграции поискового движка **Apache Lucene**. Векторный поиск становится частью экосистемы MongoDB, где эмбеддинги хранятся как поля внутри JSON-подобных BSON-документов. Это позволяет бесшовно сочетать семантический поиск с гибкой, документо-ориентированной моделью данных.

##### **2.2.2. Преимущества**

*   **Нативный гибридный поиск:** Благодаря движку Lucene, платформа "из коробки" поддерживает гибридный поиск, объединяя полнотекстовый поиск (на основе BM25) и векторный. Слияние результатов выполняется автоматически с помощью техник вроде Reciprocal Rank Fusion (RRF), что значительно упрощает реализацию сложных поисковых сценариев.
*   **Мощность Aggregation Framework:** Векторный поиск является одним из этапов (`$search` или `$vectorSearch`) в конвейере агрегации MongoDB. Это позволяет комбинировать его с десятками других операторов (`$match`, `$lookup`, `$project`) для выполнения сложной фильтрации, объединения данных и трансформации результатов в рамках одного запроса.
*   **Полностью управляемый сервис:** Платформа Atlas полностью абстрагирует задачи администрирования, включая настройку, масштабирование, шардирование и резервное копирование.
*   **Поддержка квантования:** `Atlas Vector Search` поддерживает скалярное квантование, что позволяет снизить требования к оперативной памяти и дисковому пространству.

##### **2.2.3. Недостатки и компромиссы**

*   **Привязка к поставщику (Vendor Lock-in):** Функциональность доступна исключительно в проприетарной облачной платформе MongoDB Atlas, что создает зависимость от одного вендора и его ценовой политики.
*   **Ограниченный низкоуровневый контроль:** Являясь управляемым сервисом, платформа предоставляет меньше возможностей для тонкой настройки параметров поиска и индексации по сравнению с open-source решениями.
*   **Модель "черного ящика":** Внутренние механизмы работы Lucene и его интеграции в значительной степени скрыты от пользователя, что усложняет глубокую отладку и оптимизацию производительности.


### **Раздел 3: Сравнительный анализ**

После детального рассмотрения отдельных реализаций необходимо провести их сопоставление для выявления ключевых архитектурных компромиссов. Данный раздел сначала сравнивает подходы на концептуальном уровне, а затем предоставляет тактическое сравнение конкретных технологий.

#### **3.1. Сопоставление подходов: Расширения для СУБД vs. Специализированные векторные СУБД**

Сравнение двух фундаментальных подходов выявляет компромиссы между целостностью данных, архитектурной простотой и пиковой производительностью.

| Критерий | **Расширения для универсальных СУБД (pgvector, Atlas)** | **Специализированные векторные СУБД (Qdrant, Milvus)** |
| :--- | :--- | :--- |
| **Целостность данных** | **Высокая.** Возможность использовать нативные ACID-транзакции для атомарной записи бизнес-данных и их векторов. Единый источник истины. | **Требует дополнительного контроля.** Синхронизация между основной и векторной базами данных должна управляться на уровне приложения, что создает риск рассинхронизации. |
| **Архитектурная сложность** | **Низкая.** Не вводится новый компонент в технологический стек. Используется существующая инфраструктура и экспертиза. | **Высокая.** Требуется развертывание, мониторинг и обслуживание дополнительного, независимого сервиса. Усложняется ETL-процесс. |
| **Производительность и инновации** | **Потенциально ниже.** Векторные операции конкурируют за ресурсы с другими запросами. Внедрение новейших алгоритмов (например, квантования) может запаздывать. | **Максимальная.** Все ресурсы системы сфокусированы на одной задаче. Быстрое внедрение передовых технологий и алгоритмов является ключевым конкурентным преимуществом. |
| **Гибкость фильтрации** | **Максимальная.** Позволяет использовать всю мощь нативного языка запросов (SQL) или фреймворков (Aggregation Pipeline), включая `JOIN`'ы и сложные функции. | **Ограниченная.** Предоставляются мощные, но специализированные API для фильтрации. Сложные межтабличные запросы, как правило, невозможны. |
| **Операционные издержки** | **Ниже на старте.** Используется существующая инфраструктура. Однако при масштабировании может потребоваться глубокая экспертиза в администрировании основной СУБД. | **Выше.** Требуются ресурсы и экспертиза для поддержки отдельной системы. Managed-версии могут снизить эту нагрузку, но увеличивают стоимость. |

**Вывод:** Выбор расширения для существующей СУБД является прагматичным решением, когда приоритетом является простота архитектуры и целостность данных в тесной связи с бизнес-логикой. Специализированные СУБД становятся необходимы, когда производительность векторного поиска, поддержка новейших алгоритмов и масштабируемость на больших объемах данных являются основными драйверами проекта.

#### **3.2. Тактическое сравнение: `pgvector` vs. Qdrant vs. Milvus**

Данная таблица предоставляет краткое сопоставление ключевых технических характеристик `pgvector` как представителя "генералистов" и двух популярных специализированных баз данных.

| Характеристика | **pgvector** | **Qdrant** | **Milvus** |
| :--- | :--- | :--- | :--- |
| **Парадигма** | Расширение для SQL-базы. | Нативная векторная БД. | Платформа для векторного поиска. |
| **Язык реализации** | C (внутри Postgres) | Rust | C++, Go |
| **Архитектура** | Монолитная (в рамках инстанса Postgres) | Монолитная / Распределенная (кластер) | Микросервисная |
| **Поддержка квантования** | **Нет** (на текущий момент) | **Да** (скалярное, бинарное) | **Да** (скалярное, продуктовое и др.) |
| **Модель фильтрации** | Мощь SQL, динамический выбор плана планировщиком Postgres | Payload Indexes, автоматический выбор точного/ANN поиска | Partitions, Boolean Expressions |
| **Гибридный поиск** | Требует ручной реализации (например, через `tsvector` и RRF) | Да (Sparse Vectors) | Да |
| **Сложность развертывания**| Низкая (для одного инстанса) | Низкая (для монолита), средняя (для кластера) | Высокая (предпочтительно Kubernetes) |

### **Раздел 4: Анализ платформенного подхода на примере Supabase**

Платформы класса "Бэкенд как Сервис" (BaaS) представляют собой третий подход к интеграции векторного поиска. Вместо того чтобы предоставлять инструмент, они предлагают полностью управляемую среду, где векторный поиск является одной из встроенных функций. Данный раздел анализирует этот подход на примере платформы Supabase, которая использует `pgvector` в качестве базовой технологии.

#### **4.1. Архитектура Supabase: `pgvector` как компонент сервиса**

Supabase не является самостоятельной векторной базой данных. Это комплексная BaaS-платформа, ядром которой выступает стандартный PostgreSQL. Функциональность векторного поиска реализуется посредством расширения `pgvector`, которое предустановлено и доступно "из коробки" во всех проектах.

Таким образом, Supabase следует рассматривать не как альтернативу `pgvector`, а как один из способов его развертывания и потребления. Платформа абстрагирует сложность базовой технологии и интегрирует ее в более широкую экосистему, включающую:

*   **Автоматическую генерацию API:** REST и GraphQL API создаются непосредственно из схемы базы данных.
*   **Сервис аутентификации:** Управление пользователями и правами доступа.
*   **Хранилище объектов:** S3-совместимое хранилище для файлов.
*   **Бессерверные функции (Edge Functions):** Среда для выполнения серверной логики (например, для генерации эмбеддингов).

#### **4.2. Анализ компромиссов: что Supabase решает, а что наследует**

Использование `pgvector` через Supabase фундаментально меняет баланс преимуществ и недостатков по сравнению с self-hosted решением.

##### **4.2.1. Решаемые проблемы `pgvector`**

*   **Операционная сложность:** Supabase полностью берет на себя задачи по развертыванию, настройке, обслуживанию, резервному копированию и масштабированию инстанса PostgreSQL. Это устраняет необходимость в глубокой экспертизе уровня DBA, что является значительным барьером при самостоятельном использовании `pgvector`.
*   **Скорость разработки (Developer Experience):** Платформа предоставляет удобный UI, CLI и SDK, которые значительно упрощают и ускоряют процесс разработки. Создание RAG-пайплайна, где, например, Edge Function автоматически генерирует эмбеддинг для новой записи в таблице, реализуется с минимальными усилиями.

##### **4.2.2. Наследуемые ограничения `pgvector`**

*   **Технические лимиты:** Supabase не изменяет внутреннюю механику `pgvector`. Следовательно, все его технические ограничения сохраняются:
    *   **Отсутствие нативного квантования:** Требования к оперативной памяти для больших датасетов остаются высокими, что напрямую отражается на стоимости тарифного плана.
    *   **Конкуренция за ресурсы:** Векторные операции по-прежнему конкурируют за ресурсы с другими запросами к базе данных внутри одного и того же инстанса Postgres.

#### **4.3. Выводы**

Платформенный подход, реализуемый Supabase, представляет собой компромисс, смещающий фокус с **низкоуровневого контроля и оптимизации** на **максимальную скорость разработки и удобство эксплуатации**. Он является оптимальным выбором для:

*   **Быстрого прототипирования и MVP:** Позволяет запустить проект с AI-функциональностью в кратчайшие сроки.
*   **Команд без выделенной DevOps/DBA экспертизы:** Снижает порог входа для использования мощных, но сложных технологий.
*   **Full-stack приложений,** где векторный поиск — одна из многих функций, а не ядро продукта.

При этом необходимо учитывать, что при масштабировании до очень больших объемов данных технические ограничения `pgvector` могут стать определяющим фактором, влияющим на производительность и стоимость.

### **Раздел 5: Заключение и фреймворк для принятия решений**

Выбор архитектуры для интеграции векторного поиска является многофакторной задачей, зависящей от технических требований, операционных возможностей команды и стратегических целей продукта. Представленный анализ трех подходов — специализированных СУБД, расширений для классических СУБД и платформ BaaS — позволяет сформулировать следующий фреймворк для принятия обоснованных решений.

Данный фреймворк представляет собой последовательность ключевых вопросов, ответы на которые помогут определить наиболее подходящий архитектурный путь.

#### **Вопрос 1: Какова роль векторного поиска в вашем продукте?**

*   **А) Это ядро продукта, и его производительность критична для бизнеса.**
    *   **Рекомендация:** Начать рассмотрение со **специализированных векторных баз данных** (Qdrant, Milvus). Их архитектура обеспечивает максимальную производительность, а поддержка передовых технологий (квантование, оптимизированные ANN-алгоритмы) является ключевым приоритетом.

*   **Б) Это важная фича, тесно связанная с существующими бизнес-данными.**
    *   **Рекомендация:** Начать рассмотрение с **расширений для классических баз данных** (`pgvector`, `Atlas Vector Search`). Этот подход обеспечивает целостность данных, упрощает архитектуру и позволяет использовать мощные нативные механизмы фильтрации (SQL, Aggregation Framework).

#### **Вопрос 2: Каковы текущий технологический стек и экспертиза команды?**

*   **А) В проекте уже используется PostgreSQL или MongoDB, и в команде есть соответствующая экспертиза.**
    *   **Рекомендация:** Использование `pgvector` или `Atlas Vector Search` является наиболее прагматичным первым шагом. Это минимизирует архитектурные изменения и операционные риски.

*   **Б) Проект начинается с нуля, или команда не обладает глубокой экспертизой в администрировании баз данных.**
    *   **Рекомендация:** Рассмотреть **управляемые (managed) решения**. Это могут быть как облачные версии специализированных баз (Qdrant Cloud, Pinecone), так и платформы BaaS (`Supabase`), если приоритетом является максимальная скорость разработки.

#### **Вопрос 3: Каков предполагаемый объем данных и требования к экономии ресурсов?**

*   **А) Объем данных превышает десятки миллионов векторов, и/или бюджет на инфраструктуру (особенно RAM) ограничен.**
    *   **Рекомендация:** **Поддержка квантования является обязательным требованием.** На данный момент это исключает `pgvector` (в его текущей реализации) и направляет выбор в сторону `Qdrant`, `Milvus` или `Atlas Vector Search`.

*   **Б) Объем данных находится в пределах малых и средних значений (до ~20-50 млн векторов), и стоимость RAM не является критическим блокером.**
    *   **Рекомендация:** Можно рассматривать `pgvector` и другие решения, не имеющие нативного квантования, оценивая их по другим критериям.

#### **Вопрос 4: Каковы требования к гибкости фильтрации?**

*   **А) Требуется выполнять сложные запросы с объединением данных из нескольких таблиц (`JOIN`'ы) или применять специфические функции СУБД.**
    *   **Рекомендация:** **`pgvector`** предоставляет непревзойденную гибкость благодаря полноценной поддержке SQL. Ни одно специализированное решение не может сравниться с ним в этом аспекте.

*   **Б) Фильтрация ограничивается простыми условиями по метаданным (равенство, диапазон, принадлежность к списку).**
    *   **Рекомендация:** Возможностей фильтрации большинства современных специализированных баз данных (особенно `Qdrant`) будет достаточно.

#### **Итоговая таблица-навигатор**

| **Приоритет проекта** | **Наиболее вероятный кандидат** | **Ключевой компромисс** |
| :--- | :--- | :--- |
| **Максимальная производительность и масштабируемость** | Специализированные БД (Qdrant, Milvus) | Усложнение архитектуры, синхронизация данных |
| **Целостность данных и сложные бизнес-фильтры** | `pgvector` | Требования к RAM, операционная сложность |
| **Скорость разработки и минимальные операционные затраты** | BaaS-платформы (Supabase) | Меньше контроля, наследование технических лимитов |
| **Гибкость NoSQL и нативный гибридный поиск** | `MongoDB Atlas Vector Search` | Vendor Lock-in, модель "черного ящика" |

Финальный выбор всегда является балансом между этими факторами, и данный фреймворк призван сделать этот выбор более структурированным и осознанным.